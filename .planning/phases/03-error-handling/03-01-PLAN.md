---
phase: 03-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/components/ErrorBoundary.tsx
  - frontend/app/layout.tsx
  - frontend/app/anime/[id]/page.tsx
  - frontend/app/anime/page.tsx
  - frontend/app/page.tsx
autonomous: false

must_haves:
  truths:
    - "Application has error boundary wrapping entire app"
    - "Component errors don't crash entire application"
    - "Errors are logged when components fail"
    - "Users see friendly error message instead of blank screen"
    - "Users can reset error state and retry"
  artifacts:
    - path: "frontend/components/ErrorBoundary.tsx"
      provides: "Reusable error boundary component"
      min_lines: 50
      exports: ["ErrorBoundary"]
    - path: "frontend/app/layout.tsx"
      provides: "Root error boundary wrapping entire application"
      contains: "ErrorBoundary"
    - path: "frontend/app/anime/[id]/page.tsx"
      provides: "Page-level error boundary for detail page"
      contains: "ErrorBoundary"
    - path: "frontend/app/anime/page.tsx"
      provides: "Page-level error boundary for browse page"
      contains: "ErrorBoundary"
  key_links:
    - from: "frontend/components/ErrorBoundary.tsx"
      to: "frontend/lib/logger.ts"
      via: "import logger"
      pattern: "import.*logger.*from '@/lib/logger'"
    - from: "frontend/app/layout.tsx"
      to: "frontend/components/ErrorBoundary.tsx"
      via: "component import and usage"
      pattern: "<ErrorBoundary"
---

<objective>
Create and integrate React error boundaries at page and app levels to prevent component failures from crashing the entire application, with proper error logging and user-friendly error messages.

Purpose: Implement ERR-01 requirement by adding error boundaries that catch component errors, log them for debugging, and show users friendly error messages with recovery options.
Output: Reusable ErrorBoundary component integrated at root layout and key page levels
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-logging-cleanup/01-03-SUMMARY.md
@.planning/phases/02-component-refactoring/02-03-B-SUMMARY.md

# Codebase Context
- No error boundaries currently exist (confirmed by scan)
- Phase 1 established Pino logging infrastructure with child logger pattern
- Phase 2 created DataLoadingStates component with ErrorState for consistent error UI
- React 19.2.0 available (needs react-error-boundary package for class-based ErrorBoundary)
- Current layout.tsx: ThemeProvider → ClerkThemeProvider → ConsoleFilter → Suspense → Navbar → children
</context>

<tasks>

<task type="auto">
  <name>Create reusable ErrorBoundary component</name>
  <files>frontend/components/ErrorBoundary.tsx</files>
  <action>
    Create ErrorBoundary component with:
    1. Install react-error-boundary package: `npm install react-error-boundary` (from frontend directory)
    2. Create frontend/components/ErrorBoundary.tsx as client component ("use client")
    3. Use ErrorBoundary from react-error-boundary package as base
    4. Implement fallback component that renders error UI with:
       - Error message (error.message or generic "Something went wrong")
       - Optional error details in development (error.stack)
       - "Try again" button that calls resetErrorBoundary()
       - Consistent styling using shadcn/ui Alert component
    5. Add onError callback that logs to Pino logger: `logger.error({ error, errorInfo }, 'Component error caught by boundary')`
    6. Props interface: { children: React.ReactNode, fallback?: ReactNode, onError?: (error: Error, errorInfo: ErrorInfo) => void }
    7. Export default ErrorBoundary

    Error UI pattern: Use Alert component from shadcn/ui (similar to ErrorState from DataLoadingStates but for boundary failures)
    Logging: Use logger from @/lib/logger with error context
  </action>
  <verify>
    - Component file exists and exports ErrorBoundary
    - TypeScript compiles without errors: `cd frontend && npx tsc --noEmit`
    - Component is client component with "use client" directive
    - onError callback logs errors properly
  </verify>
  <done>
    ErrorBoundary component exists with proper error logging and user-friendly error UI with retry button
  </done>
</task>

<task type="auto">
  <name>Integrate ErrorBoundary at root layout level</name>
  <files>frontend/app/layout.tsx</files>
  <action>
    Wrap the entire application with ErrorBoundary:
    1. Import ErrorBoundary from @/components/ErrorBoundary
    2. Wrap existing content with <ErrorBoundary> component
    3. Keep existing structure: ThemeProvider → ClerkThemeProvider → ErrorBoundary → ConsoleFilter → Suspense → Navbar → children
    4. No props needed (default fallback and onError)

    This ensures any component failure in the app is caught at the root level.
  </action>
  <verify>
    - layout.tsx imports ErrorBoundary
    - ErrorBoundary wraps entire app content
    - TypeScript compiles without errors
    - Dev server starts without errors: `cd frontend && npm run dev` (verify in background, then stop)
  </verify>
  <done>
    Root layout has error boundary wrapping entire application
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>ErrorBoundary component integrated at root layout level</what-built>
  <how-to-verify>
    1. Start dev server: `cd frontend && npm run dev`
    2. Open http://localhost:3000
    3. Trigger an error in browser console:
       - Open DevTools Console
       - Run: `document.querySelector('a').click()` (triggers null reference error)
    4. Expected behavior:
       - Application shows error fallback UI (NOT blank screen)
       - Error UI shows friendly message "Something went wrong"
       - Error UI shows "Try again" button
       - Error is logged in terminal (check server logs)
    5. Click "Try again" button
    6. Expected: Application recovers and shows normal UI
    7. Check terminal logs for error log entry with error context
  </how-to-verify>
  <resume-signal>Type "approved" if error boundary works as expected, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. ErrorBoundary component created and exported from frontend/components/ErrorBoundary.tsx
2. react-error-boundary package installed
3. Root layout (layout.tsx) wrapped with ErrorBoundary
4. Component errors caught and logged to Pino logger
5. Error UI shows friendly message with retry button
6. Application recovers after clicking "Try again"
7. TypeScript compilation successful with zero errors
8. Dev server runs without errors
9. Manual test confirms error boundary prevents app crash
</verification>

<success_criteria>
1. ✓ react-error-boundary package installed
2. ✓ ErrorBoundary component exists with fallback UI and error logging
3. ✓ Root layout has ErrorBoundary wrapping entire application
4. ✓ Component failures don't crash entire app
5. ✓ Errors logged with context (error object, error info)
6. ✓ Users see friendly error message instead of blank screen
7. ✓ Retry button resets error state and recovers application
8. ✓ TypeScript compilation successful
9. ✓ Manual verification passed (user approved)
</success_criteria>

<output>
After completion, create `.planning/phases/03-error-handling/03-01-SUMMARY.md`
</output>
