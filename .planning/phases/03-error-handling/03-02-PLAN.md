---
phase: 03-error-handling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/services/animeService.ts
  - frontend/services/anilistService.ts
  - frontend/services/animeCacheService.ts
autonomous: true

must_haves:
  truths:
    - "All service functions have try-catch blocks"
    - "Service errors logged with full context"
    - "Functions throw errors with descriptive messages"
    - "Database errors handled gracefully"
    - "External API errors logged and re-thrown"
  artifacts:
    - path: "frontend/services/animeService.ts"
      provides: "Core anime data service with error handling"
      contains: "try\\s*\\{"
    - path: "frontend/services/anilistService.ts"
      provides: "AniList integration service with error handling"
      contains: "try\\s*\\{"
    - path: "frontend/services/animeCacheService.ts"
      provides: "Cache service with error handling"
      contains: "try\\s*\\{"
  key_links:
    - from: "frontend/services/animeService.ts"
      to: "frontend/lib/logger.ts"
      via: "import logger"
      pattern: "import.*logger.*from '@/lib/logger'"
    - from: "frontend/services/anilistService.ts"
      to: "frontend/lib/logger.ts"
      via: "import logger"
      pattern: "import.*logger.*from '@/lib/logger'"
    - from: "frontend/services/animeCacheService.ts"
      to: "frontend/lib/logger.ts"
      via: "import logger"
      pattern: "import.*logger.*from '@/lib/logger'"
---

<objective>
Add comprehensive try-catch error handling to all service layer functions with proper logging and descriptive error messages.

Purpose: Implement ERR-02 requirement by ensuring all service functions handle errors gracefully, log them for debugging, and throw descriptive errors to calling code.
Output: Service layer functions with robust error handling and logging
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-logging-cleanup/01-02-SUMMARY.md

# Codebase Context
- animeService.ts: Core service with database queries, NO try-catch currently (needs wrapping)
- anilistService.ts: AniList integration, has partial try-catch (needs review/completion)
- animeCacheService.ts: Cache service with Redis-ready pattern, needs try-catch
- jikanService.ts: Already has try-catch in all functions (Phase 1 logging)
- Pino logger infrastructure available with child logger pattern
- Service functions called by API routes which have their own try-catch
</context>

<tasks>

<task type="auto">
  <name>Add error handling to animeService.ts functions</name>
  <files>frontend/services/animeService.ts</files>
  <action>
    Add try-catch blocks to ALL exported async functions in animeService.ts:

    Functions to wrap (confirmed by reading file):
    - getAnime() - database query for single anime
    - getAnimeList() - database query with filtering/pagination
    - searchAnime() - database full-text search
    - getRecommendations() - vector similarity search
    - upsertAnime() - database insert/update
    - deleteAnime() - database delete
    - upsertReview() - review insert/update
    - deleteReview() - review delete
    - getUserReviews() - database query for reviews

    Pattern for each function:
    ```typescript
    export async function functionName(params: Type): Promise<ReturnType> {
      try {
        // existing function body
        return result;
      } catch (error) {
        animeLogger.error({ error, params }, 'Descriptive error message');
        throw new Error('Failed to [action]');
      }
    }
    ```

    Important:
    - Create child logger at top: `const animeLogger = logger.child({ service: 'AnimeService' });`
    - Log error with context (function parameters, error object)
    - Re-throw with descriptive error message
    - Keep existing function logic intact
    - Don't double-wrap functions that already have try-catch (check first)

    This file has NO try-catch currently, so ALL exported functions need wrapping.
  </action>
  <verify>
    - All exported functions have try-catch blocks
    - Error logging uses animeLogger with error context
    - Errors re-thrown with descriptive messages
    - TypeScript compiles without errors: `cd frontend && npx tsc --noEmit`
    - Existing functionality preserved (no logic changes)
  </verify>
  <done>
    All animeService.ts functions have try-catch with proper logging and descriptive error messages
  </done>
</task>

<task type="auto">
  <name>Add error handling to anilistService.ts functions</name>
  <files>frontend/services/anilistService.ts</files>
  <action>
    Review and complete error handling in anilistService.ts:

    1. Read the file to identify which functions have try-catch and which don't
    2. For functions WITHOUT try-catch, add error handling following same pattern as Task 1
    3. For functions WITH try-catch, verify logging is using child logger pattern
    4. Create child logger: `const anilistLogger = logger.child({ service: 'AniListService' });`
    5. Ensure all errors logged with context and re-thrown with descriptive messages

    Functions to check (grep for 'export async function'):
    - All exported async functions in the file

    Pattern: Same as Task 1, but only modify functions that need it
  </action>
  <verify>
    - All exported functions have try-catch blocks
    - Error logging uses anilistLogger with error context
    - Errors re-thrown with descriptive messages
    - TypeScript compiles without errors
    - Existing functionality preserved
  </verify>
  <done>
    All anilistService.ts functions have proper error handling and logging
  </done>
</task>

<task type="auto">
  <name>Add error handling to animeCacheService.ts functions</name>
  <files>frontend/services/animeCacheService.ts</files>
  <action>
    Add try-catch blocks to ALL exported async functions in animeCacheService.ts:

    1. Read the file to identify all exported functions
    2. Create child logger: `const cacheLogger = logger.child({ service: 'AnimeCacheService' });`
    3. Add try-catch to all functions following same pattern as Task 1
    4. Log errors with cache operation context (key, operation, error)
    5. Re-throw with descriptive error messages

    Functions to wrap (grep for 'export async function'):
    - All exported async functions in the file

    Pattern: Same as Task 1, ensuring cache operations are properly error-handled
  </action>
  <verify>
    - All exported functions have try-catch blocks
    - Error logging uses cacheLogger with error context
    - Errors re-thrown with descriptive messages
    - TypeScript compiles without errors
    - Existing functionality preserved
  </verify>
  <done>
    All animeCacheService.ts functions have proper error handling and logging
  </done>
</task>

</tasks>

<verification>
1. animeService.ts: All exported functions have try-catch with animeLogger
2. anilistService.ts: All exported functions have try-catch with anilistLogger
3. animeCacheService.ts: All exported functions have try-catch with cacheLogger
4. All errors logged with context (params, operation, error object)
5. All errors re-thrown with descriptive messages
6. TypeScript compilation successful with zero errors
7. Existing functionality preserved (no logic changes, only error handling added)
8. grep confirms try-catch in all service functions
</verification>

<success_criteria>
1. ✓ All service functions wrapped in try-catch
2. ✓ Child loggers created (animeLogger, anilistLogger, cacheLogger)
3. ✓ Errors logged with full context (params, error object)
4. ✓ Descriptive error messages thrown to callers
5. ✓ Database errors handled gracefully
6. ✓ External API errors logged and re-thrown
7. ✓ TypeScript compilation successful
8. ✓ Zero logic changes (only error handling added)
</success_criteria>

<output>
After completion, create `.planning/phases/03-error-handling/03-02-SUMMARY.md`
</output>
