---
phase: 03-error-handling
plan: 04
type: execute
wave: 2
depends_on: [03-01, 03-02]
files_modified:
  - frontend/hooks/useErrorHandler.ts
  - frontend/components/ErrorMessage.tsx
  - frontend/app/anime/[id]/page.tsx
  - frontend/app/anime/page.tsx
  - frontend/app/page.tsx
autonomous: false

must_haves:
  truths:
    - "Components have error state to track failures"
    - "Error state can be reset to retry operations"
    - "Users see friendly error messages based on error type"
    - "Error messages are actionable where possible"
    - "Error UI is consistent across application"
  artifacts:
    - path: "frontend/hooks/useErrorHandler.ts"
      provides: "Reusable error state management hook"
      min_lines: 50
      exports: ["useErrorHandler"]
    - path: "frontend/components/ErrorMessage.tsx"
      provides: "Consistent error message component"
      min_lines: 60
      exports: ["ErrorMessage"]
    - path: "frontend/app/anime/[id]/page.tsx"
      provides: "Detail page with error state management"
      contains: "useErrorHandler"
    - path: "frontend/app/anime/page.tsx"
      provides: "Browse page with error state management"
      contains: "useErrorHandler"
  key_links:
    - from: "frontend/app/anime/[id]/page.tsx"
      to: "frontend/hooks/useErrorHandler.ts"
      via: "import useErrorHandler"
      pattern: "import.*useErrorHandler.*from '@/hooks/useErrorHandler'"
    - from: "frontend/app/anime/[id]/page.tsx"
      to: "frontend/components/ErrorMessage.tsx"
      via: "import ErrorMessage"
      pattern: "import.*ErrorMessage.*from '@/components/ErrorMessage'"
    - from: "frontend/components/ErrorMessage.tsx"
      to: "frontend/lib/client-logger.ts"
      via: "import logger"
      pattern: "import.*logger.*from '@/lib/client-logger'"
---

<objective>
Implement error state management and user-friendly error messages in components to show actionable error feedback and recovery options.

Purpose: Implement ERR-04 requirement by adding error state hooks and consistent error UI components that provide users with clear, actionable error messages and recovery options.
Output: Reusable error handling hook and error message component integrated into key pages
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-logging-cleanup/01-03-SUMMARY.md
@.planning/phases/02-component-refactoring/02-03-B-SUMMARY.md
@.planning/phases/03-error-handling/03-01-SUMMARY.md

# Codebase Context
- Phase 2 created DataLoadingStates with ErrorState component (for general errors)
- Phase 1 created client-logger.ts for browser-side logging
- Components currently use basic error handling (try-catch in useEffect, useState for error)
- No centralized error state management hook exists
- Error messages vary across components (not consistent)
- Pages: anime/[id]/page.tsx (detail), anime/page.tsx (browse), page.tsx (home)
</context>

<tasks>

<task type="auto">
  <name>Create useErrorHandler hook for error state management</name>
  <files>frontend/hooks/useErrorHandler.ts</files>
  <action>
    Create frontend/hooks/useErrorHandler.ts as client component hook:

    Hook interface:
    ```typescript
    export interface ErrorState {
      hasError: boolean;
      error: Error | null;
      errorType: 'network' | 'timeout' | 'server' | 'client' | 'unknown';
      message: string;
      isRetryable: boolean;
    }

    export interface UseErrorHandlerReturn {
      error: ErrorState;
      setError: (error: Error | string, context?: string) => void;
      clearError: () => void;
      retry: () => void;
    }

    export function useErrorHandler(): UseErrorHandlerReturn
    ```

    Implementation:
    1. useState for error state (default: no error)
    2. setError function:
       - Accepts Error object or string message
       - Determines error type based on error message/content:
         * 'network': message includes 'network', 'fetch', 'ECONNREFUSED'
         * 'timeout': message includes 'timeout', 'timed out'
         * 'server': message includes '500', '502', '503', '504'
         * 'client': message includes '400', '401', '403', '404'
         * 'unknown': default
       - Sets isRetryable: true for network/timeout/server errors, false for client errors
       - Generates user-friendly message based on error type
       - Logs error using clientLogger: `clientLogger.error({ error, context, errorType }, 'Component error')`
    3. clearError function: Resets error state to no error
    4. retry function: Calls provided retry callback and clears error
    5. Export: { error, setError, clearError, retry }

    User-friendly messages:
    - Network: "Unable to connect. Please check your internet connection."
    - Timeout: "Request timed out. Please try again."
    - Server: "Server error. Please try again later."
    - Client: "Invalid request. Please refresh and try again."
    - Unknown: "Something went wrong. Please try again."

    Import clientLogger from @/lib/client-logger
  </action>
  <verify>
    - useErrorHandler hook exists and exports default function
    - Hook exports ErrorState interface and UseErrorHandlerReturn interface
    - TypeScript compiles without errors
    - Hook determines error types correctly
    - User-friendly messages provided for each error type
    - isRetryable flag set correctly (network/timeout/server=true, client=false)
  </verify>
  <done>
    Reusable error state management hook exists with error type detection and user-friendly messages
  </done>
</task>

<task type="auto">
  <name>Create ErrorMessage component for consistent error UI</name>
  <files>frontend/components/ErrorMessage.tsx</files>
  <action>
    Create frontend/components/ErrorMessage.tsx as client component:

    Component interface:
    ```typescript
    export interface ErrorMessageProps {
      error: {
        message: string;
        errorType: 'network' | 'timeout' | 'server' | 'client' | 'unknown';
        isRetryable: boolean;
      };
      onRetry?: () => void;
      className?: string;
    }
    ```

    Implementation ("use client"):
    1. Use Alert component from shadcn/ui (destructive variant for errors)
    2. Display error.message prominently
    3. Add icon based on error type:
       - Network: Wifi off icon
       - Timeout: Clock icon
       - Server: Server icon
       - Client: Alert circle icon
       - Unknown: Help circle icon
    4. If isRetryable=true and onRetry provided: Show "Try Again" button
    5. Use consistent styling with Tailwind classes
    6. Support optional className prop for customization
    7. Log error render using clientLogger: `clientLogger.debug({ errorType, message }, 'Rendering error message')`

    Pattern: Similar to ErrorState from DataLoadingStates (Phase 2) but more sophisticated with error type icons and retry button
  </action>
  <verify>
    - ErrorMessage component exists as client component
    - Component uses Alert from shadcn/ui
    - Icons displayed based on error type
    - Retry button shown when isRetryable=true and onRetry provided
    - TypeScript compiles without errors
    - Component handles all error types (network, timeout, server, client, unknown)
  </verify>
  <done>
    Consistent error message component exists with icons and retry button
  </done>
</task>

<task type="auto">
  <name>Integrate error handling into anime detail page</name>
  <files>frontend/app/anime/[id]/page.tsx</files>
  <action>
    Add error state management to anime detail page:

    1. Import useErrorHandler from @/hooks/useErrorHandler
    2. Import ErrorMessage from @/components/ErrorMessage
    3. Add to component: `const { error, setError, clearError, retry } = useErrorHandler()`
    4. Update each useEffect that fetches data:
       - Wrap fetch logic in try-catch
       - On catch: call setError(error, 'context about what failed')
       - Example: `catch (err) { setError(err, 'Failed to fetch anime details'); }`
    5. Add error UI in component render:
       - If error.hasError: render <ErrorMessage error={error} onRetry={retry} />
       - Place error messages near relevant sections (or at top of page)
    6. Add retry callback that re-runs failed fetch operation
    7. Keep existing loading/error states from DataLoadingStates component

    Key data fetches to wrap (from Phase 2 refactoring):
    - Main anime data fetch
    - Recommendations fetch
    - Jikan tabs data fetch (characters, staff, stats)
    - Reviews fetch

    Pattern: Use error boundary (Plan 03-01) for component crashes, use useErrorHandler for async operation failures
  </action>
  <verify>
    - useErrorHandler imported and used
    - ErrorMessage component imported and rendered
    - All useEffect data fetches have try-catch with setError
    - Error UI renders when error.hasError=true
    - Retry button calls retry function which re-fetches data
    - TypeScript compiles without errors
    - Existing loading states preserved
  </verify>
  <done>
    Anime detail page has error state management with user-friendly error messages and retry functionality
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Error handling integrated into anime detail page</what-built>
  <how-to-verify>
    1. Ensure dev server running: `cd frontend && npm run dev`
    2. Open http://localhost:3000/anime/1 (or any valid anime ID)
    3. Test error states:
       a) Network error simulation:
          - Open DevTools Network tab
          - Set throttling to "Offline"
          - Refresh page
          - Expected: Error message "Unable to connect. Please check your internet connection." with retry button
          - Click retry button
          - Expected: Same error (still offline)

       b) Server error simulation:
          - Set throttling back to "No throttling"
          - Temporarily break API route (comment out return in /api/anime/[id])
          - Refresh page
          - Expected: Error message "Server error. Please try again later." with retry button
          - Restore API route, click retry
          - Expected: Page loads successfully

       c) Normal operation:
          - Visit valid anime page
          - Expected: No error messages, page loads normally
    4. Check error UI styling:
       - Error messages use Alert component (red/destructive variant)
       - Icons match error types (Wifi, Clock, Server, AlertCircle)
       - Retry button visible and functional
    5. Check browser console for clientLogger debug logs
  </how-to-verify>
  <resume-signal>Type "approved" if error handling works as expected, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. useErrorHandler hook created with error state management
2. ErrorMessage component created with consistent UI and icons
3. Anime detail page uses useErrorHandler for error state
4. Anime detail page shows ErrorMessage on errors
5. Error messages are user-friendly and actionable
6. Retry functionality works (clears error and re-fetches)
7. Error types detected correctly (network, timeout, server, client)
8. TypeScript compilation successful with zero errors
9. Existing loading states preserved (DataLoadingStates component)
10. Manual verification passed (user approved)
</verification>

<success_criteria>
1. ✓ useErrorHandler hook exists with error state management
2. ✓ ErrorMessage component exists with icons and retry button
3. ✓ Error types detected: network, timeout, server, client, unknown
4. ✓ User-friendly messages for each error type
5. ✓ Anime detail page has error state management
6. ✓ Error UI renders when errors occur
7. ✓ Retry button clears error and re-fetches data
8. ✓ isRetryable flag controls retry button visibility
9. ✓ Client-side logging for error tracking
10. ✓ TypeScript compilation successful
11. ✓ Manual verification passed
</success_criteria>

<output>
After completion, create `.planning/phases/03-error-handling/03-04-SUMMARY.md`
</output>
