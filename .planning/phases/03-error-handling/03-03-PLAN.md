---
phase: 03-error-handling
plan: 03
type: execute
wave: 2
depends_on: [03-02]
files_modified:
  - frontend/lib/retry.ts
  - frontend/services/jikanService.ts
  - frontend/services/anilistService.ts
autonomous: true

must_haves:
  truths:
    - "Failed API calls automatically retry with exponential backoff"
    - "Retries happen up to 3 times with increasing delays"
    - "Retry logic logs attempts for debugging"
    - "Permanent errors (4xx) don't retry"
    - "Transient errors (5xx, network) trigger retries"
  artifacts:
    - path: "frontend/lib/retry.ts"
      provides: "Reusable retry utility with exponential backoff"
      min_lines: 60
      exports: ["retryWithBackoff"]
    - path: "frontend/services/jikanService.ts"
      provides: "Jikan API integration with retry logic"
      contains: "retryWithBackoff"
    - path: "frontend/services/anilistService.ts"
      provides: "AniList API integration with retry logic"
      contains: "retryWithBackoff"
  key_links:
    - from: "frontend/services/jikanService.ts"
      to: "frontend/lib/retry.ts"
      via: "import retryWithBackoff"
      pattern: "import.*retryWithBackoff.*from '@/lib/retry'"
    - from: "frontend/services/anilistService.ts"
      to: "frontend/lib/retry.ts"
      via: "import retryWithBackoff"
      pattern: "import.*retryWithBackoff.*from '@/lib/retry'"
    - from: "frontend/lib/retry.ts"
      to: "frontend/lib/logger.ts"
      via: "import logger"
      pattern: "import.*logger.*from '@/lib/logger'"
---

<objective>
Implement exponential backoff retry logic for failed external API calls to improve reliability for transient failures.

Purpose: Implement ERR-03 requirement by adding automatic retry logic with exponential backoff for external API calls (Jikan, AniList) to handle transient failures gracefully.
Output: Reusable retry utility integrated into external service calls
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-logging-cleanup/01-02-SUMMARY.md
@.planning/phases/03-error-handling/03-02-SUMMARY.md

# Codebase Context
- jikanService.ts: External API integration with rate limiting, needs retry logic
- anilistService.ts: External API integration, needs retry logic
- No retry utility currently exists in codebase
- Phase 1 established Pino logging for retry attempt tracking
- Jikan API: Rate-limited (3 req/sec, 60 req/min), can return 429 errors
- AniList API: GraphQL-based, can return 5xx errors
- Plan 03-02 added try-catch to these services (depends on that work)
</context>

<tasks>

<task type="auto">
  <name>Create reusable retry utility with exponential backoff</name>
  <files>frontend/lib/retry.ts</files>
  <action>
    Create frontend/lib/retry.ts with retryWithBackoff function:

    Function signature:
    ```typescript
    export interface RetryOptions {
      maxRetries?: number;
      baseDelay?: number;
      maxDelay?: number;
      shouldRetry?: (error: any) => boolean;
      onRetry?: (attempt: number, error: any) => void;
    }

    export async function retryWithBackoff<T>(
      fn: () => Promise<T>,
      options?: RetryOptions
    ): Promise<T>
    ```

    Implementation:
    1. Default options: maxRetries=3, baseDelay=1000ms (1s), maxDelay=10000ms (10s)
    2. Exponential backoff: delay = baseDelay * Math.pow(2, attempt) (capped at maxDelay)
    3. shouldRetry function determines if error is retryable (default: retry on network errors and 5xx status, not 4xx)
    4. onRetry callback logs retry attempts with attempt number and error
    5. Loop: try fn(), catch error, check shouldRetry, if yes wait delay and retry, if no throw
    6. Add jitter: delay * (0.5 + Math.random() * 0.5) to avoid thundering herd
    7. Import logger for retry attempt logging: `logger.debug({ attempt, error, delay }, 'Retrying request')`

    Error detection:
    - Network errors: !error.response (no response object)
    - 5xx errors: error.response?.status >= 500
    - 429 rate limit: error.response?.status === 429
    - Don't retry 4xx client errors (400-499 except 429)

    Logging: Use Pino logger with retry context
  </action>
  <verify>
    - retry.ts file exists with retryWithBackoff function
    - TypeScript compiles without errors
    - Function exports RetryOptions interface
    - Function has proper JSDoc/TSDoc comments
  </verify>
  <done>
    Reusable retry utility exists with exponential backoff, jitter, and smart error detection
  </done>
</task>

<task type="auto">
  <name>Integrate retry logic into jikanService.ts</name>
  <files>frontend/services/jikanService.ts</files>
  <action>
    Wrap external API calls in jikanService.ts with retryWithBackoff:

    Functions to update (from Task 1 of Plan 03-02):
    - searchJikanAnime() - wraps jikanClient.anime.getAnimeSearch()
    - getJikanAnimeById() - wraps jikanClient.anime.getAnimeById()
    - getCurrentSeasonAnime() - wraps jikanClient.seasons.getSeasonNow()
    - getUpcomingAnime() - wraps jikanClient.seasons.getSeasonUpcoming()

    Pattern:
    ```typescript
    export async function searchJikanAnime(query: string, limit: number = 10): Promise<NormalizedAnimeData[]> {
      try {
        const result = await rateLimiter.throttle(async () => {
          return await retryWithBackoff(async () => {
            return await jikanClient.anime.getAnimeSearch({ q: query, limit, order_by: 'popularity' });
          }, {
            maxRetries: 3,
            onRetry: (attempt, error) => {
              jikanLogger.debug({ attempt, error, query, limit }, 'Retrying Jikan API call');
            }
          });
        });
        return result.data.map((anime: any) => normalizeJikanData(anime));
      } catch (error) {
        jikanLogger.error({ error, query, limit }, 'Error searching Jikan anime');
        throw new Error('Failed to search anime on Jikan');
      }
    }
    ```

    Important:
    - Keep existing rateLimiter.throttle wrapper (rate limiting still needed)
    - Wrap only the jikanClient API call with retryWithBackoff
    - Add onRetry callback to log retry attempts
    - Keep existing try-catch and error handling (Plan 03-02 work)
    - Import retryWithBackoff from @/lib/retry

    Note: getJikanAnimeByIds() uses Promise.allSettled and calls getJikanAnimeById, so retry logic will apply automatically
  </action>
  <verify>
    - All Jikan API calls wrapped with retryWithBackoff
    - Retry attempts logged with jikanLogger
    - Rate limiting still works (rateLimiter.throttle preserved)
    - TypeScript compiles without errors
    - Existing error handling preserved
  </verify>
  <done>
    Jikan API calls automatically retry 3 times with exponential backoff on transient failures
  </done>
</task>

<task type="auto">
  <name>Integrate retry logic into anilistService.ts</name>
  <files>frontend/services/anilistService.ts</files>
<action>
    Wrap external API calls in anilistService.ts with retryWithBackoff:

    1. Read the file to identify all AniList API calls (likely using fetch or axios)
    2. For each API call, wrap with retryWithBackoff following same pattern as Task 2
    3. Add onRetry callback with anilistLogger for retry attempt logging
    4. Keep existing try-catch and error handling (Plan 03-02 work)
    5. Import retryWithBackoff from @/lib/retry

    Pattern:
    ```typescript
    export async function someAnilistFunction(params: Type): Promise<ReturnType> {
      try {
        const result = await retryWithBackoff(async () => {
          // existing AniList API call
        }, {
          maxRetries: 3,
          onRetry: (attempt, error) => {
            anilistLogger.debug({ attempt, error, params }, 'Retrying AniList API call');
          }
        });
        return result;
      } catch (error) {
        anilistLogger.error({ error, params }, 'Error calling AniList API');
        throw new Error('Failed to fetch from AniList');
      }
    }
    ```

    Apply to all exported functions that make external API calls.
  </action>
  <verify>
    - All AniList API calls wrapped with retryWithBackoff
    - Retry attempts logged with anilistLogger
    - TypeScript compiles without errors
    - Existing error handling preserved
  </verify>
  <done>
    AniList API calls automatically retry 3 times with exponential backoff on transient failures
  </done>
</task>

</tasks>

<verification>
1. retry.ts utility created with retryWithBackoff function
2. Exponential backoff implemented: 1s → 2s → 4s (max 10s)
3. Jitter added to avoid thundering herd
4. Smart error detection: retry 5xx/network/429, don't retry 4xx
5. jikanService.ts: All API calls wrapped with retry logic
6. anilistService.ts: All API calls wrapped with retry logic
7. Retry attempts logged with attempt number and error context
8. Rate limiting preserved in jikanService.ts
9. TypeScript compilation successful with zero errors
</verification>

<success_criteria>
1. ✓ Reusable retry utility exists (retry.ts)
2. ✓ Exponential backoff: 1s → 2s → 4s (capped at 10s)
3. ✓ Jitter added (0.5x - 1.0x random multiplier)
4. ✓ Smart error detection (5xx/network/429 retry, 4xx don't)
5. ✓ All Jikan API calls wrapped with retryWithBackoff
6. ✓ All AniList API calls wrapped with retryWithBackoff
7. ✓ Retry attempts logged with context
8. ✓ maxRetries=3 by default (configurable)
9. ✓ TypeScript compilation successful
</success_criteria>

<output>
After completion, create `.planning/phases/03-error-handling/03-03-SUMMARY.md`
</output>
