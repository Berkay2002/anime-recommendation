---
phase: 05-api-optimization
plan: 05
type: execute
wave: 3
depends_on: ["05-01", "05-03"]
files_modified:
  - frontend/app/anime/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Detail page uses useQueries for parallel execution"
    - "Recommendations, reviews, and details load simultaneously (not sequentially)"
    - "Loading states work for each section independently"
    - "Page load time reduced by at least 50% compared to sequential loading"
  artifacts:
    - path: "frontend/app/anime/[id]/page.tsx"
      provides: "Detail page with parallel queries"
      min_lines: 150
      contains: "useQueries"
  key_links:
    - from: "frontend/app/anime/[id]/page.tsx"
      to: "frontend/lib/queries/anime.ts"
      via: "import query hooks"
      pattern: "import.*use.*from.*@/lib/queries/anime"
    - from: "frontend/app/anime/[id]/page.tsx"
      to: "Multiple /api/anime/* endpoints"
      via: "Parallel useQueries execution"
      pattern: "useQueries.*queries:.*\\["
---

<objective>
Migrate detail page to use parallel queries with React Query's useQueries hook

Purpose: Convert sequential API calls (details → recommendations → reviews) to parallel execution
Output: Detail page with ~2-3x faster load time due to parallelized queries
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

@.planning/phases/05-api-optimization/05-RESEARCH.md
@.planning/phases/05-api-optimization/05-CONTEXT.md
@.planning/phases/05-api-optimization/05-01-SUMMARY.md
@.planning/phases/05-api-optimization/05-03-SUMMARY.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md

@frontend/app/anime/[id]/page.tsx
@frontend/lib/queries/anime.ts
</context>

<tasks>

<task type="auto">
  <name>Migrate detail page to parallel queries</name>
  <files>frontend/app/anime/[id]/page.tsx</files>
  <action>
    Refactor frontend/app/anime/[id]/page.tsx to use parallel queries:

    1. Add new imports:
       ```typescript
       import { useQueries } from '@tanstack/react-query'
       import { useAnimeDetail, useRecommendations, useReviews } from '@/lib/queries/anime'
       ```

    2. Replace the three separate useEffect hooks with a single useQueries call:

       Find the three useEffect blocks:
       - `useEffect(() => { fetchAnimeDetails() }, [numericId])` - fetches main anime
       - `useEffect(() => { fetchRecommendations() }, [anime])` - fetches recommendations
       - `useEffect(() => { fetchReviews() }, [anime])` - fetches reviews

       Replace them all with:
       ```typescript
       // BEFORE: 3 separate useEffect hooks (sequential)
       // useEffect(() => { fetchAnimeDetails() }, [numericId])
       // useEffect(() => { fetchRecommendations() }, [anime])
       // useEffect(() => { fetchReviews() }, [anime])

       // AFTER: Single useQueries call (parallel)
       const results = useQueries({
         queries: [
           {
             queryKey: ['anime', 'detail', numericId],
             queryFn: () => fetch(`/api/anime?limit=1000`).then(r => r.json()).then(data => {
               const animeList = data.anime || []
               return animeList.find((item: Anime) => item.anime_id === numericId) || null
             }),
             enabled: !!numericId,
             staleTime: 5 * 60 * 1000, // 5 minutes
           },
           {
             queryKey: ['anime', numericId, 'recommendations'],
             queryFn: () => fetch(`/api/anime/recommendation/${numericId}`).then(r => r.json()),
             enabled: !!numericId,
             staleTime: 5 * 60 * 1000,
           },
           {
             queryKey: ['anime', numericId, 'reviews'],
             queryFn: () => fetch(`/api/anime/reviews/${numericId}`).then(r => r.json()),
             enabled: !!numericId,
             staleTime: 5 * 60 * 1000,
           },
         ],
         combine: (results) => ({
           anime: results[0].data,
           recommendations: results[1].data?.similar_anime || [],
           reviews: results[2].data?.reviews || [],
           isLoading: results.some(r => r.isLoading),
           errors: results.filter(r => r.error).map(r => r.error),
         })
       })

       const { anime, recommendations, reviews, isLoading, errors } = results
       ```

    3. Remove old state management:
       - Delete: `const [anime, setAnime] = useState<Anime | null>(null)`
       - Delete: `const [recommendations, setRecommendations] = useState<Recommendation[]>([])`
       - Delete: `const [reviews, setReviews] = useState<string[]>([])`
       - Delete: `const [details, setDetails] = useState<JikanDetails | null>(null)`
       - Delete: `const [detailsLoading, setDetailsLoading] = useState<boolean>(false)`
       - Delete: `const [detailsError, setDetailsError] = useState<string | null>(null)`

    4. Update error handling:
       - Remove: `const mainError = useErrorHandler()`, `const recommendationsError = useErrorHandler()`, etc.
       - Use `errors` array from useQueries combine result

    5. Update loading states:
       - Remove: `const { isLoading: loading, setIsLoading } = useLoadingState(150)`
       - Remove: `const { isLoading: recommendationsLoading, setIsLoading: setRecommendationsLoading } = useLoadingState(150)`
       - Remove: `const { isLoading: reviewsLoading, setIsLoading: setReviewsLoading } = useLoadingState(150)`
       - Use combined `isLoading` from useQueries result
       - Remove all `setIsLoading` calls throughout the component

    6. Update JSX to handle errors array:
       ```typescript
       {errors.length > 0 && (
         <ErrorMessage
           error={errors[0]}
           onRetry={() => window.location.reload()}
         />
       )}
       ```

    Reference: RESEARCH.md "Example 3: Parallel Queries on Anime Detail Page"

    Key benefit: All 3 queries fire in parallel instead of waiting for each other
    Expected performance: ~1 second total instead of ~3 seconds (3x faster)
  </action>
  <verify>grep -q "useQueries" frontend/app/anime/[id]/page.tsx && ! grep -q "useEffect.*fetchAnimeDetails\|useEffect.*fetchRecommendations\|useEffect.*fetchReviews" frontend/app/anime/[id]/page.tsx</verify>
  <done>Detail page migrated to useQueries with parallel execution of all data fetches</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit` (in frontend directory)
2. ESLint passes: `npm run lint` (in frontend directory)
3. Manual testing:
   - Start dev server: `cd frontend && npm run dev`
   - Visit detail page at http://localhost:3000/anime/1 (or any anime ID)
   - Open browser Network tab and filter by "fetch/XHR"
   - Refresh page and observe:
     - All 3 requests (anime list, recommendations, reviews) should fire simultaneously
     - Total load time should be ~1 second (not ~3 seconds)
   - Open React Query DevTools and verify 3 queries appear in parallel
4. Verify page renders correctly with all data loaded
5. Verify error handling works (try invalid anime ID)
</verification>

<success_criteria>
1. Detail page uses useQueries hook for parallel data fetching
2. All 3 queries (anime, recommendations, reviews) fire simultaneously
3. Page load time reduced by at least 50% compared to sequential loading
4. Loading states work correctly during parallel fetch
5. Error handling works with errors array
6. All existing functionality preserved
7. No TypeScript or ESLint errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-optimization/05-05-SUMMARY.md`
</output>
