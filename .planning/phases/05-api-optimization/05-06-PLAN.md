---
phase: 05-api-optimization
plan: 06
type: execute
wave: 3
depends_on: ["05-01", "05-03"]
files_modified:
  - frontend/components/SearchBar.tsx
  - frontend/hooks/useRecommendations.ts
  - frontend/lib/queries/anime.ts
autonomous: true

must_haves:
  truths:
    - "SearchBar uses React Query with 1-minute cache for search results"
    - "RecommendedSection uses React Query with 5-minute cache"
    - "No duplicate search API calls for same search term"
    - "React Query DevTools shows all queries with appropriate cache times"
  artifacts:
    - path: "frontend/components/SearchBar.tsx"
      provides: "Search component with React Query caching"
      min_lines: 100
      contains: "useQuery"
    - path: "frontend/hooks/useRecommendations.ts"
      provides: "Recommendations hook with React Query caching"
      min_lines: 100
      contains: "useQuery"
    - path: "frontend/lib/queries/anime.ts"
      provides: "Query hooks for search and recommendations"
      exports: ["useAnimeSearch", "useAllAnimeWithEmbeddings"]
  key_links:
    - from: "frontend/components/SearchBar.tsx"
      to: "frontend/lib/queries/anime.ts"
      via: "useAnimeSearch import"
      pattern: "import.*useAnimeSearch.*from.*@/lib/queries/anime"
    - from: "frontend/hooks/useRecommendations.ts"
      to: "frontend/lib/queries/anime.ts"
      via: "useAllAnimeWithEmbeddings import"
      pattern: "import.*useAllAnimeWithEmbeddings.*from.*@/lib/queries/anime"
---

<objective>
Optimize search and recommendation flows with React Query caching and deduplication

Purpose: Reduce redundant API calls in high-frequency operations (search, recommendations)
Output: Search and recommendation components using React Query with appropriate cache durations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

@.planning/phases/05-api-optimization/05-RESEARCH.md
@.planning/phases/05-api-optimization/05-CONTEXT.md
@.planning/phases/05-api-optimization/05-01-SUMMARY.md
@.planning/phases/05-api-optimization/05-03-SUMMARY.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md

@frontend/components/SearchBar.tsx
@frontend/components/RecommendedSection.tsx
@frontend/hooks/useRecommendations.ts
@frontend/lib/queries/anime.ts
</context>

<tasks>

<task type="auto">
  <name>Add search and anime list query hooks</name>
  <files>frontend/lib/queries/anime.ts</files>
  <action>
    Extend frontend/lib/queries/anime.ts with search and anime list hooks:

    1. Add to query key factory:
       ```typescript
       export const animeKeys = {
         // ... existing keys ...
         search: (query: string) => ['anime', 'search', query] as const,
         allWithEmbeddings: () => ['anime', 'all', 'embeddings'] as const,
       }
       ```

    2. Add search fetcher:
       ```typescript
       async function fetchAnimeSearch(query: string): Promise<Anime[]> {
         if (!query.trim()) return []
         const response = await fetch(`/api/anime/search?q=${encodeURIComponent(query)}`)
         if (!response.ok) {
           throw new Error(`Failed to search anime: ${response.status}`)
         }
         const data = await response.json()
         return data.anime || []
       }
       ```

    3. Add anime list with embeddings fetcher (for useRecommendations hook):
       ```typescript
       async function fetchAllAnimeWithEmbeddings(): Promise<Anime[]> {
         const response = await fetch('/api/anime?withEmbeddings=true&limit=657&sortBy=Popularity')
         if (!response.ok) {
           throw new Error(`Failed to fetch anime with embeddings: ${response.status}`)
         }
         const data = await response.json()
         return data.anime || []
       }
       ```

    4. Add query hooks:
       ```typescript
       export function useAnimeSearch(query: string) {
         return useQuery({
           queryKey: animeKeys.search(query),
           queryFn: () => fetchAnimeSearch(query),
           enabled: query.trim().length > 0, // Only run if query is not empty
           staleTime: 1 * 60 * 1000, // 1 minute for search results (CONTEXT.md decision)
         })
       }

       export function useAllAnimeWithEmbeddings() {
         return useQuery({
           queryKey: animeKeys.allWithEmbeddings(),
           queryFn: fetchAllAnimeWithEmbeddings,
           staleTime: 10 * 60 * 1000, // 10 minutes for full anime list with embeddings
         })
       }
       ```

    Reference: CONTEXT.md decisions for cache durations (search: 1min, embeddings: 10min)
  </action>
  <verify>grep -q "export function useAnimeSearch" frontend/lib/queries/anime.ts && grep -q "export function useAllAnimeWithEmbeddings" frontend/lib/queries/anime.ts</verify>
  <done>Query hooks added for search (1min cache) and anime list with embeddings (10min cache)</done>
</task>

<task type="auto">
  <name>Migrate SearchBar to React Query</name>
  <files>frontend/components/SearchBar.tsx</files>
  <action>
    Refactor SearchBar component to use useAnimeSearch hook:

    1. Add import:
       ```typescript
       import { useAnimeSearch } from '@/lib/queries/anime'
       ```

    2. Replace useEffect data fetching with useAnimeSearch:
       ```typescript
       // BEFORE:
       // useEffect(() => {
       //   const searchAnime = async (query) => {
       //     setIsLoading(true)
       //     const response = await fetch(`/api/anime/search?q=${query}`)
       //     const data = await response.json()
       //     setResults(data.anime || [])
       //     setIsLoading(false)
       //   }
       //   searchAnime(debouncedQuery)
       // }, [debouncedQuery])

       // AFTER:
       const { data: searchResults = [], isLoading, error } = useAnimeSearch(debouncedQuery)
       ```

    3. Remove manual state management:
       - Delete: `const [results, setResults] = useState<Anime[]>([])`
       - Delete: `const { isLoading, setIsLoading } = useLoadingState(150)`
       - Remove all `setIsLoading` calls

    4. Update references to `results` â†’ `searchResults`

    5. Update error handling:
       - Use `error` from React Query instead of manual error state

    Reference: Same pattern as browse page migration (05-04)
  </action>
  <verify>grep -q "import.*useAnimeSearch.*from.*@/lib/queries/anime" frontend/components/SearchBar.tsx && ! grep -q "useEffect.*searchAnime" frontend/components/SearchBar.tsx</verify>
  <done>SearchBar migrated to useAnimeSearch with automatic caching and deduplication</done>
</task>

<task type="auto">
  <name>Migrate useRecommendations hook to React Query</name>
  <files>frontend/hooks/useRecommendations.ts</files>
  <action>
    Refactor useRecommendations hook to use useAllAnimeWithEmbeddings from React Query:

    The current implementation (lines 36-105) fetches all anime with embeddings via useEffect.
    We'll replace this with React Query while preserving the Web Worker logic for similarity computation.

    1. Add import:
       ```typescript
       import { useAllAnimeWithEmbeddings } from '@/lib/queries/anime'
       ```

    2. Replace the first useEffect (fetchAllAnime) with useAllAnimeWithEmbeddings hook:
       ```typescript
       // BEFORE (lines 36-105): useEffect that fetches all anime
       // const [allAnime, setAllAnime] = useState<Anime[]>([])
       // useEffect(() => { ... fetchAllAnime() ... }, [])

       // AFTER: Use React Query hook
       const { data: allAnime = [], isLoading: isAllAnimeLoading, error: allAnimeError } =
         useAllAnimeWithEmbeddings()
       ```

    3. Remove state variables that are now handled by React Query:
       - Delete: `const [allAnime, setAllAnime] = useState<Anime[]>([])`
       - Keep: `const [recommendedAnime, setRecommendedAnime] = useState<Anime[]>([])` (computed from Web Worker)
       - Keep: `const { isLoading, setIsLoading } = useLoadingState()` (for Web Worker computation)
       - Keep: `const [error, setError] = useState<string | null>(null)` (for Web Worker errors)
       - Keep: `const [worker, setWorker] = useState<Worker | null>(null)` (Web Worker instance)

    4. Update the second useEffect (Web Worker similarity computation) to use React Query data:
       - Remove the early return `if (!allAnime.length) { setIsLoading(true); return }`
       - The `allAnime` is now from React Query, not state
       - Update dependency array: remove `allAnime`, keep `selectedAnimeIds` (allAnime is stable from React Query)
       - Update error handling to combine `allAnimeError` with Web Worker errors

    5. Update loading state management:
       - Replace `isAllAnimeLoading` with the `isLoading` from useAllAnimeWithEmbeddings
       - Keep `setIsLoading` for Web Worker computation (separate concern)

    6. Update error handling:
       - Display `allAnimeError` if fetching anime list fails
       - Display Web Worker errors (from `error` state) if similarity computation fails

    7. Update the return statement to expose both loading states:
       ```typescript
       return {
         recommendedAnime,
         isLoading: isLoading || isAllAnimeLoading, // Combined loading state
         error: error || allAnimeError, // Combined error state
         cancelRecommendations
       }
       ```

    Key principle: Use React Query for API fetching, keep Web Worker for similarity computation
    This preserves the existing Web Worker logic while leveraging React Query caching
  </action>
  <verify>grep -q "import.*useAllAnimeWithEmbeddings.*from.*@/lib/queries/anime" frontend/hooks/useRecommendations.ts && ! grep -q "useState.*allAnime.*setAllAnime" frontend/hooks/useRecommendations.ts</verify>
  <done>useRecommendations migrated to useAllAnimeWithEmbeddings with caching (Web Worker logic preserved)</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit` (in frontend directory)
2. ESLint passes: `npm run lint` (in frontend directory)
3. Manual testing:
   - Start dev server: `cd frontend && npm run dev`
   - Test search:
     - Type "naruto" in search bar
     - Verify results appear
     - Clear search, type "naruto" again
     - Verify results load instantly from cache (check Network tab - no duplicate request)
   - Test recommendations:
     - Select anime for recommendations
     - Verify recommendations appear
     - Deselect and reselect same anime
     - Verify anime list loads from cache (check React Query DevTools)
     - Verify Web Worker still computes similarity (console logs or DevTools)
4. Open React Query DevTools and verify:
   - Search queries have 1min staleTime
   - All anime with embeddings query has 10min staleTime
   - No duplicate queries for same search term
</verification>

<success_criteria>
1. SearchBar uses useAnimeSearch hook with 1-minute cache
2. useRecommendations uses useAllAnimeWithEmbeddings with 10-minute cache
3. Web Worker logic for similarity computation is preserved
4. No duplicate API calls for same search term or recommendation selection
5. All existing functionality preserved (search filtering, recommendation generation)
6. Cache durations match CONTEXT.md decisions (1min search, 10min embeddings)
7. No TypeScript or ESLint errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-optimization/05-06-SUMMARY.md`
</output>
