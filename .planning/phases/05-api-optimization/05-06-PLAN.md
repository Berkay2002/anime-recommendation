---
phase: 05-api-optimization
plan: 06
type: execute
wave: 3
depends_on: ["05-01", "05-03"]
files_modified:
  - frontend/components/SearchBar.tsx
  - frontend/components/RecommendedSection.tsx
  - frontend/lib/queries/anime.ts
autonomous: true

must_haves:
  truths:
    - "SearchBar uses React Query with 1-minute cache for search results"
    - "RecommendedSection uses React Query with 5-minute cache"
    - "No duplicate search API calls for same search term"
    - "React Query DevTools shows all queries with appropriate cache times"
  artifacts:
    - path: "frontend/components/SearchBar.tsx"
      provides: "Search component with React Query caching"
      min_lines: 100
      contains: "useQuery"
    - path: "frontend/components/RecommendedSection.tsx"
      provides: "Recommendations with React Query caching"
      min_lines: 80
      contains: "useQuery"
    - path: "frontend/lib/queries/anime.ts"
      provides: "Query hooks for search and recommendations"
      exports: ["useAnimeSearch", "useRecommendationGeneration"]
  key_links:
    - from: "frontend/components/SearchBar.tsx"
      to: "frontend/lib/queries/anime.ts"
      via: "useAnimeSearch import"
      pattern: "import.*useAnimeSearch.*from.*@/lib/queries/anime"
    - from: "frontend/components/RecommendedSection.tsx"
      to: "frontend/lib/queries/anime.ts"
      via: "useRecommendationGeneration import"
      pattern: "import.*useRecommendationGeneration.*from.*@/lib/queries/anime"
---

<objective>
Optimize search and recommendation flows with React Query caching and deduplication

Purpose: Reduce redundant API calls in high-frequency operations (search, recommendations)
Output: Search and recommendation components using React Query with appropriate cache durations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

@.planning/phases/05-api-optimization/05-RESEARCH.md
@.planning/phases/05-api-optimization/05-CONTEXT.md
@.planning/phases/05-api-optimization/05-01-SUMMARY.md
@.planning/phases/05-api-optimization/05-03-SUMMARY.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md

@frontend/components/SearchBar.tsx
@frontend/components/RecommendedSection.tsx
@frontend/lib/queries/anime.ts
</context>

<tasks>

<task type="auto">
  <name>Add search and recommendation query hooks</name>
  <files>frontend/lib/queries/anime.ts</files>
  <action>
    Extend frontend/lib/queries/anime.ts with search and recommendation hooks:

    1. Add to query key factory:
       ```typescript
       export const animeKeys = {
         // ... existing keys ...
         search: (query: string) => ['anime', 'search', query] as const,
         generate: (selections: number[]) => ['anime', 'generate', selections] as const,
       }
       ```

    2. Add search fetcher:
       ```typescript
       async function fetchAnimeSearch(query: string): Promise<Anime[]> {
         if (!query.trim()) return []
         const response = await fetch(`/api/anime/search?q=${encodeURIComponent(query)}`)
         if (!response.ok) {
           throw new Error(`Failed to search anime: ${response.status}`)
         }
         const data = await response.json()
         return data.anime || []
       }
       ```

    3. Add recommendation generation fetcher:
       ```typescript
       interface GenerationRequest {
         selected_anime: number[]
       }

       interface GenerationResponse {
         similar_anime?: Recommendation[]
       }

       async function generateRecommendations(selections: number[]): Promise<GenerationResponse> {
         if (selections.length === 0) {
           throw new Error('No anime selected for recommendation generation')
         }
         const response = await fetch('/api/anime/recommendation', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({ selected_anime: selections }),
         })
         if (!response.ok) {
           throw new Error(`Failed to generate recommendations: ${response.status}`)
         }
         return response.json()
       }
       ```

    4. Add query hooks:
       ```typescript
       export function useAnimeSearch(query: string) {
         return useQuery({
           queryKey: animeKeys.search(query),
           queryFn: () => fetchAnimeSearch(query),
           enabled: query.trim().length > 0, // Only run if query is not empty
           staleTime: 1 * 60 * 1000, // 1 minute for search results (CONTEXT.md decision)
         })
       }

       export function useRecommendationGeneration(selections: number[]) {
         return useQuery({
           queryKey: animeKeys.generate(selections),
           queryFn: () => generateRecommendations(selections),
           enabled: selections.length > 0, // Only run if selections exist
           staleTime: 5 * 60 * 1000, // 5 minutes for recommendations (CONTEXT.md decision)
         })
       }
       ```

    Reference: CONTEXT.md decisions for cache durations (search: 1min, recommendations: 5min)
  </action>
  <verify>grep -q "export function useAnimeSearch" frontend/lib/queries/anime.ts && grep -q "export function useRecommendationGeneration" frontend/lib/queries/anime.ts</verify>
  <done>Query hooks added for search (1min cache) and recommendations (5min cache)</done>
</task>

<task type="auto">
  <name>Migrate SearchBar to React Query</name>
  <files>frontend/components/SearchBar.tsx</files>
  <action>
    Refactor SearchBar component to use useAnimeSearch hook:

    1. Add import:
       ```typescript
       import { useAnimeSearch } from '@/lib/queries/anime'
       ```

    2. Replace useEffect data fetching with useAnimeSearch:
       ```typescript
       // BEFORE:
       // useEffect(() => {
       //   const searchAnime = async (query) => {
       //     setIsLoading(true)
       //     const response = await fetch(`/api/anime/search?q=${query}`)
       //     const data = await response.json()
       //     setResults(data.anime || [])
       //     setIsLoading(false)
       //   }
       //   searchAnime(debouncedQuery)
       // }, [debouncedQuery])

       // AFTER:
       const { data: searchResults = [], isLoading, error } = useAnimeSearch(debouncedQuery)
       ```

    3. Remove manual state management:
       - Delete: `const [results, setResults] = useState<Anime[]>([])`
       - Delete: `const { isLoading, setIsLoading } = useLoadingState(150)`
       - Remove all `setIsLoading` calls

    4. Update references to `results` â†’ `searchResults`

    5. Update error handling:
       - Use `error` from React Query instead of manual error state

    Reference: Same pattern as browse page migration (05-04)
  </action>
  <verify>grep -q "import.*useAnimeSearch.*from.*@/lib/queries/anime" frontend/components/SearchBar.tsx && ! grep -q "useEffect.*searchAnime" frontend/components/SearchBar.tsx</verify>
  <done>SearchBar migrated to useAnimeSearch with automatic caching and deduplication</done>
</task>

<task type="auto">
  <name>Migrate RecommendedSection to React Query</name>
  <files>frontend/components/RecommendedSection.tsx</files>
  <action>
    Refactor RecommendedSection component to use useRecommendationGeneration hook:

    1. Read current RecommendedSection implementation to understand data fetching pattern
    2. Add import:
       ```typescript
       import { useRecommendationGeneration } from '@/lib/queries/anime'
       ```

    3. Replace existing data fetching with useRecommendationGeneration:
       ```typescript
       // BEFORE (existing pattern - likely useEffect or similar):
       // const [recommendations, setRecommendations] = useState([])
       // const [isLoading, setIsLoading] = useState(false)

       // AFTER:
       const { data: recommendations = [], isLoading, error } = useRecommendationGeneration(selectedAnime)

       const recommendedAnime = useMemo(() => {
         return recommendations.map(rec => ({
           anime_id: rec.anime_id,
           title: rec.title,
           image_url: rec.image_url,
           score: rec.score,
           popularity: rec.popularity,
           genres: rec.genres,
           bert_description: [],
           bert_genres: [],
           bert_demographic: [],
           bert_rating: [],
           bert_themes: [],
         }))
       }, [recommendations])
       ```

    4. Remove manual state management for recommendations and loading
    5. Update error handling to use React Query error
    6. Keep existing progress tracking logic (useProgress) - it's UI state, not data fetching

    Note: This component may have complex state management - preserve all existing functionality
  </action>
  <verify>grep -q "import.*useRecommendationGeneration.*from.*@/lib/queries/anime" frontend/components/RecommendedSection.tsx && ! grep -q "useState.*recommendations\|useState.*Recommendations" frontend/components/RecommendedSection.tsx</verify>
  <done>RecommendedSection migrated to useRecommendationGeneration with caching</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit` (in frontend directory)
2. ESLint passes: `npm run lint` (in frontend directory)
3. Manual testing:
   - Start dev server: `cd frontend && npm run dev`
   - Test search:
     - Type "naruto" in search bar
     - Verify results appear
     - Clear search, type "naruto" again
     - Verify results load instantly from cache (check Network tab - no duplicate request)
   - Test recommendations:
     - Select anime for recommendations
     - Verify recommendations appear
     - Deselect and reselect same anime
     - Verify recommendations load from cache (check React Query DevTools)
4. Open React Query DevTools and verify:
   - Search queries have 1min staleTime
   - Recommendation queries have 5min staleTime
   - No duplicate queries for same search term or selection
</verification>

<success_criteria>
1. SearchBar uses useAnimeSearch hook with 1-minute cache
2. RecommendedSection uses useRecommendationGeneration hook with 5-minute cache
3. No duplicate API calls for same search term or recommendation selection
4. All existing functionality preserved (search filtering, recommendation generation)
5. Cache durations match CONTEXT.md decisions (1min search, 5min recommendations)
6. No TypeScript or ESLint errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-optimization/05-06-SUMMARY.md`
</output>
