---
phase: 05-api-optimization
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/lib/queries/anime.ts
autonomous: true

must_haves:
  truths:
    - "Query functions can be imported and used in components"
    - "Query keys are type-safe and follow factory pattern"
    - "Fetcher functions handle errors and return typed data"
    - "No TypeScript errors in query functions"
  artifacts:
    - path: "frontend/lib/queries/anime.ts"
      provides: "Query functions and hooks for anime data fetching"
      min_lines: 80
      exports: ["animeKeys", "useAnimeList", "useAnimeDetail", "useRecommendations", "useReviews"]
  key_links:
    - from: "frontend/lib/queries/anime.ts"
      to: "/api/anime endpoints"
      via: "fetch calls"
      pattern: "fetch.*api/anime"
    - from: "(future components)"
      to: "frontend/lib/queries/anime.ts"
      via: "import query hooks"
      pattern: "import.*useAnime.*from.*@/lib/queries/anime"
---

<objective>
Create reusable query functions library with React Query hooks and type-safe query keys

Purpose: Establish separation of concerns - query logic separate from components
Output: Working query hooks that can replace useEffect data fetching
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

@.planning/phases/05-api-optimization/05-RESEARCH.md
@.planning/phases/05-api-optimization/05-CONTEXT.md
@.planning/phases/05-api-optimization/05-01-SUMMARY.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md

@frontend/app/anime/page.tsx
@frontend/app/anime/[id]/page.tsx
@frontend/app/api/anime/route.ts
</context>

<tasks>

<task type="auto">
  <name>Create query functions library</name>
  <files>frontend/lib/queries/anime.ts</files>
  <action>
    Create new lib/queries/anime.ts file with query hooks:

    ```typescript
    import { useQuery } from '@tanstack/react-query'
    import { clientLogger } from '@/lib/client-logger'

    // Type definitions (matching existing interfaces)
    export interface Anime {
      anime_id: number
      title: string
      image_url?: string
      Genres?: string[]
      Score?: number
      Description?: string
      Rank?: number
      popularity?: number
      demographic?: string
      rating?: string
    }

    export interface AnimeListResponse {
      anime: Anime[]
      totalPages: number
      currentPage: number
    }

    export interface Recommendation {
      anime_id: number
      title: string
      image_url?: string
      score?: number
      popularity?: number
      genres?: string[]
      similarity: number
    }

    export interface Review {
      review_text: string
    }

    // Query key factory (type-safe query keys)
    export const animeKeys = {
      all: ['anime'] as const,
      lists: () => [...animeKeys.all, 'list'] as const,
      list: (filters: { sortBy?: string; genres?: string[]; page?: number; limit?: number }) =>
        [...animeKeys.lists(), filters] as const,
      details: () => [...animeKeys.all, 'detail'] as const,
      detail: (id: number) => [...animeKeys.details(), id] as const,
      recommendations: (id: number) => ['anime', id, 'recommendations'] as const,
      reviews: (id: number) => ['anime', id, 'reviews'] as const,
    }

    // Fetcher functions
    async function fetchAnimeList(params: {
      sortBy?: string
      genres?: string[]
      page?: number
      limit?: number
    }): Promise<AnimeListResponse> {
      const queryParams = new URLSearchParams()
      if (params.sortBy) queryParams.set('sortBy', params.sortBy)
      if (params.genres && params.genres.length > 0) {
        queryParams.set('genres', params.genres.join(','))
      }
      if (params.page) queryParams.set('page', params.page.toString())
      if (params.limit) queryParams.set('limit', params.limit.toString())

      const response = await fetch(`/api/anime?${queryParams.toString()}`)
      if (!response.ok) {
        throw new Error(`Failed to fetch anime: ${response.status}`)
      }
      return response.json()
    }

    async function fetchAnimeDetail(id: number): Promise<Anime[]> {
      const response = await fetch(`/api/anime?limit=1000`)
      if (!response.ok) {
        throw new Error(`Failed to fetch anime: ${response.status}`)
      }
      const payload = await response.json()
      const animeList: Anime[] = payload.anime || []
      return animeList.filter((item) => item.anime_id === id)
    }

    async function fetchRecommendations(id: number): Promise<{ similar_anime?: Recommendation[] }> {
      const response = await fetch(`/api/anime/recommendation/${id}`)
      if (!response.ok) {
        throw new Error(`Failed to fetch recommendations: ${response.status}`)
      }
      return response.json()
    }

    async function fetchReviews(id: number): Promise<{ reviews?: Review[] }> {
      const response = await fetch(`/api/anime/reviews/${id}`)
      if (!response.ok) {
        throw new Error(`Failed to fetch reviews: ${response.status}`)
      }
      return response.json()
    }

    // Query hooks
    export function useAnimeList(params: {
      sortBy?: string
      genres?: string[]
      page?: number
      limit?: number
    }) {
      return useQuery({
        queryKey: animeKeys.list(params),
        queryFn: () => fetchAnimeList(params),
        staleTime: 2 * 60 * 1000, // 2 minutes for browse results (CONTEXT.md decision)
      })
    }

    export function useAnimeDetail(id: number) {
      return useQuery({
        queryKey: animeKeys.detail(id),
        queryFn: () => fetchAnimeDetail(id),
        enabled: !!id, // Only run query if id is provided
        staleTime: 5 * 60 * 1000, // 5 minutes for anime details (CONTEXT.md decision)
      })
    }

    export function useRecommendations(id: number) {
      return useQuery({
        queryKey: animeKeys.recommendations(id),
        queryFn: () => fetchRecommendations(id),
        enabled: !!id,
        staleTime: 5 * 60 * 1000, // 5 minutes
      })
    }

    export function useReviews(id: number) {
      return useQuery({
        queryKey: animeKeys.reviews(id),
        queryFn: () => fetchReviews(id),
        enabled: !!id,
        staleTime: 5 * 60 * 1000, // 5 minutes
      })
    }
    ```

    Reference: RESEARCH.md "Pattern 2: Query Functions Separation"

    Key decisions from CONTEXT.md:
    - Variable staleTime: browse 2min, details 5min
    - Type-safe query key factory pattern
    - Fetcher functions separate from hooks
  </action>
  <verify>test -f frontend/lib/queries/anime.ts && grep -q "export const animeKeys" frontend/lib/queries/anime.ts && grep -q "export function useAnimeList" frontend/lib/queries/anime.ts</verify>
  <done>Query functions library created with type-safe keys and reusable hooks</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit` (in frontend directory)
2. ESLint passes: `npm run lint` (in frontend directory)
3. File exports can be imported: verify by checking exports in file
4. Query keys follow factory pattern (all, lists, list, details, detail, etc.)
5. All hooks have appropriate staleTime values set
</verification>

<success_criteria>
1. Query functions library created at frontend/lib/queries/anime.ts
2. Type-safe query key factory implemented
3. Four query hooks exported: useAnimeList, useAnimeDetail, useRecommendations, useReviews
4. All hooks have appropriate staleTime (2min for browse, 5min for details)
5. No TypeScript or ESLint errors
6. Hooks ready to be imported into components
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-optimization/05-03-SUMMARY.md`
</output>
