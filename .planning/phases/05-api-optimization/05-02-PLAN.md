---
phase: 05-api-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/migrations/add_indexes.sql
autonomous: false

must_haves:
  truths:
    - "EXPLAIN ANALYZE shows index usage instead of sequential scans"
    - "Query execution time reduced by at least 25% for browse page queries"
    - "Indexes created without blocking application (CONCURRENTLY)"
    - "No data loss or corruption from index creation"
  artifacts:
    - path: "backend/migrations/add_indexes.sql"
      provides: "PostgreSQL indexes for query optimization"
      min_lines: 20
      contains: "CREATE INDEX CONCURRENTLY"
    - path: ".planning/phases/05-api-optimization/05-02-ANALYSIS.md"
      provides: "Before/after query performance analysis"
      min_lines: 30
  key_links:
    - from: "backend/migrations/add_indexes.sql"
      to: "PostgreSQL database"
      via: "psql or database client"
      pattern: "CREATE INDEX.*ON anime"
---

<objective>
Optimize database queries with targeted indexes on frequently filtered columns

Purpose: Reduce database query latency to achieve <100ms response time for common operations
Output: Working database indexes with documented performance improvements
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

@.planning/phases/05-api-optimization/05-RESEARCH.md
@.planning/phases/05-api-optimization/05-CONTEXT.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Analyze current query performance with EXPLAIN ANALYZE</what-built>
  <how-to-verify>
    Before creating indexes, measure baseline performance:

    1. Connect to PostgreSQL database using psql or database client
    2. Run EXPLAIN ANALYZE on browse page query:
       ```sql
       EXPLAIN ANALYZE
       SELECT a.anime_id, a.title, a.image_url, a.score, a.popularity, a.rank
       FROM anime a
       WHERE a.popularity IS NOT NULL
       ORDER BY a.popularity ASC
       LIMIT 50;
       ```
    3. Record the execution time and note if it shows "Seq Scan" (sequential scan)
    4. Run similar analysis for other filtered columns:
       - ORDER BY score DESC
       - ORDER BY rank ASC
       - WHERE genre = 'Action'

    5. Save results to `.planning/phases/05-api-optimization/05-02-ANALYSIS.md` with:
       - Query text
       - Execution time before indexes
       - Execution plan (EXPLAIN output)
       - Notes on bottlenecks identified
  </how-to-verify>
  <resume-signal>Type "analyzed" or provide the baseline performance numbers</resume-signal>
</task>

<task type="auto">
  <name>Create database index migration script</name>
  <files>backend/migrations/add_indexes.sql</files>
  <action>
    Create SQL migration file with targeted indexes:

    ```sql
    -- Add indexes to improve query performance
    -- Using CONCURRENTLY to avoid blocking application

    -- Index on popularity (frequently used for sorting/browse page)
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_anime_popularity
    ON anime(popularity)
    WHERE popularity IS NOT NULL;

    -- Index on score (frequently used for sorting)
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_anime_score
    ON anime(score)
    WHERE score IS NOT NULL;

    -- Index on rank (frequently used for sorting)
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_anime_rank
    ON anime(rank)
    WHERE rank IS NOT NULL;

    -- Comment: Partial indexes (WHERE ... IS NOT NULL) are more efficient
    -- because we only query anime that have these values set
    ```

    Reference: RESEARCH.md "Example 4: Database Indexing for Performance"
  </action>
  <verify>test -f backend/migrations/add_indexes.sql && grep -q "CREATE INDEX CONCURRENTLY" backend/migrations/add_indexes.sql</verify>
  <done>Migration script created with indexes on popularity, score, and rank columns</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <what-built>Apply database indexes to production database</what-built>
  <how-to-verify>
    This step requires human action to apply indexes to the production database:

    1. Connect to your PostgreSQL database (Neon console or psql client)
    2. Run the migration script:
       ```bash
       psql -f backend/migrations/add_indexes.sql $DATABASE_URL
       ```
       Or execute each CREATE INDEX statement manually in database client

    3. Wait for index creation to complete (may take several minutes depending on data size)

    4. Verify indexes were created:
       ```sql
       SELECT indexname, tablename
       FROM pg_indexes
       WHERE tablename = 'anime'
       AND indexname LIKE 'idx_anime_%';
       ```

    Expected output: idx_anime_popularity, idx_anime_score, idx_anime_rank

    5. Re-run EXPLAIN ANALYZE from previous task:
       ```sql
       EXPLAIN ANALYZE
       SELECT a.anime_id, a.title, a.image_url, a.score, a.popularity, a.rank
       FROM anime a
       WHERE a.popularity IS NOT NULL
       ORDER BY a.popularity ASC
       LIMIT 50;
       ```

    6. Update `.planning/phases/05-api-optimization/05-02-ANALYSIS.md` with:
       - Execution time after indexes
       - New execution plan (should show "Index Scan" instead of "Seq Scan")
       - Performance improvement percentage
  </how-to-verify>
  <resume-signal>Type "indexed" after indexes are created and performance improvement measured</resume-signal>
</task>

</tasks>

<verification>
1. Indexes exist in database: `SELECT indexname FROM pg_indexes WHERE tablename = 'anime' AND indexname LIKE 'idx_anime_%'`
2. EXPLAIN ANALYZE shows "Index Scan" instead of "Seq Scan" for filtered queries
3. Query execution time reduced by at least 25% compared to baseline
4. Application still functions correctly (no query errors)
5. Browse page loads noticeably faster
</verification>

<success_criteria>
1. Database indexes created on popularity, score, and rank columns
2. Query performance improved by at least 25% (measured via EXPLAIN ANALYZE)
3. No application errors from schema changes
4. Before/after performance documented in ANALYSIS.md
5. Browse page query response time < 100ms (target from success criteria)
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-optimization/05-02-SUMMARY.md`
</output>
