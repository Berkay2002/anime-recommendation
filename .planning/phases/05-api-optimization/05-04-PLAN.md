---
phase: 05-api-optimization
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-03"]
files_modified:
  - frontend/app/anime/page.tsx
autonomous: true

must_haves:
  truths:
    - "Browse page uses useAnimeList hook instead of useEffect"
    - "Loading states work correctly with React Query status"
    - "No duplicate API calls when changing filters or pagination"
    - "Data is cached for 2 minutes (staleTime)"
  artifacts:
    - path: "frontend/app/anime/page.tsx"
      provides: "Browse page migrated to React Query"
      min_lines: 100
      contains: "useAnimeList"
  key_links:
    - from: "frontend/app/anime/page.tsx"
      to: "frontend/lib/queries/anime.ts"
      via: "useAnimeList import"
      pattern: "import.*useAnimeList.*from.*@/lib/queries/anime"
    - from: "frontend/app/anime/page.tsx"
      to: "/api/anime"
      via: "React Query automatic fetching"
      pattern: "useAnimeList.*queryFn.*fetch"
---

<objective>
Migrate browse page from useEffect data fetching to React Query hooks

Purpose: Eliminate manual useEffect fetching, leverage React Query caching and deduplication
Output: Browse page using useAnimeList hook with automatic caching
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

@.planning/phases/05-api-optimization/05-RESEARCH.md
@.planning/phases/05-api-optimization/05-CONTEXT.md
@.planning/phases/05-api-optimization/05-01-SUMMARY.md
@.planning/phases/05-api-optimization/05-03-SUMMARY.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md

@frontend/app/anime/page.tsx
@frontend/lib/queries/anime.ts
</context>

<tasks>

<task type="auto">
  <name>Migrate browse page to React Query</name>
  <files>frontend/app/anime/page.tsx</files>
  <action>
    Refactor frontend/app/anime/page.tsx to use React Query:

    1. Remove old imports (useEffect, useState for data, useLoadingState):
       - Keep useState for UI state (selectedGenres, currentPage, sortBy)
       - Keep useDebounce and useLocalStorage
       - Remove useState for animeList, totalPages, error, loading

    2. Add new imports:
       ```typescript
       import { useAnimeList } from '@/lib/queries/anime'
       ```

    3. Replace useEffect data fetching with useAnimeList hook:
       ```typescript
       // BEFORE (old useEffect):
       // useEffect(() => {
       //   const fetchAnime = (page, sortByValue, genres) => { ... }
       //   fetchAnime(currentPage, debouncedSortBy, debouncedSelectedGenres)
       // }, [currentPage, debouncedSortBy, debouncedSelectedGenres])

       // AFTER (React Query):
       const { data, isLoading, error } = useAnimeList({
         page: currentPage,
         sortBy: debouncedSortBy,
         genres: debouncedSelectedGenres,
         limit: 50,
       })

       const animeList = data?.anime || []
       const totalPages = data?.totalPages || 0
       ```

    4. Remove manual error state management:
       - Delete `const [error, setError] = useState<string | null>(null)`
       - Use `error` from React Query directly

    5. Update loading state:
       - Remove `const { isLoading: loading, setIsLoading } = useLoadingState(150)`
       - Use `isLoading` from React Query directly
       - Remove all `setIsLoading` calls

    6. Update error handling in JSX:
       - Replace `{error && <div>{error}</div>}` with:
       ```typescript
       {error && (
         <Alert variant="destructive">
           <AlertTitle>Error</AlertTitle>
           <AlertDescription>
             Failed to load anime list. Please try again later.
           </AlertDescription>
         </Alert>
       )}
       ```

    7. Update loading condition:
       - Replace `{loading && isInitialLoad ? <AnimeBrowseSkeleton /> : ...}`
       - With: `{isLoading && isInitialLoad ? <AnimeBrowseSkeleton /> : ...}`

    8. Remove error handling from fetch catch block:
       - Delete the `.catch((fetchError: Error) => { ... })` block
       - React Query handles errors automatically

    Reference: RESEARCH.md "Example 2: Migrating Existing useEffect to useQuery"

    Key principle: Remove manual data fetching, let React Query handle caching, loading, and errors
  </action>
  <verify>grep -q "import.*useAnimeList.*from.*@/lib/queries/anime" frontend/app/anime/page.tsx && ! grep -q "useEffect.*fetchAnime" frontend/app/anime/page.tsx</verify>
  <done>Browse page migrated to useAnimeList hook with automatic caching and loading states</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit` (in frontend directory)
2. ESLint passes: `npm run lint` (in frontend directory)
3. Manual testing:
   - Start dev server: `cd frontend && npm run dev`
   - Visit browse page at http://localhost:3000/anime
   - Verify page loads with anime list
   - Change genre filter - should fetch new data
   - Change sort option - should fetch new data
   - Change page - should fetch new data
   - Open React Query DevTools and verify query appears under "anime" key
4. Verify no duplicate requests in Network tab when changing filters
5. Verify data is cached (revisit same page/filter combination - should load from cache)
</verification>

<success_criteria>
1. Browse page uses useAnimeList hook instead of manual useEffect fetching
2. Loading states work correctly (isLoading from React Query)
3. Error handling works (error from React Query)
4. No duplicate API calls for same filter combination
5. Data is cached for 2 minutes (verify in DevTools)
6. All existing functionality preserved (filters, pagination, sorting)
7. No TypeScript or ESLint errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-optimization/05-04-SUMMARY.md`
</output>
