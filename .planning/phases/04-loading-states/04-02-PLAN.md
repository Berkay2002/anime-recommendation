---
phase: 04-loading-states
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/hooks/useLoadingState.ts
  - frontend/hooks/useFetchData.ts
autonomous: true

must_haves:
  truths:
    - "Loading states delay 100-200ms before showing to prevent flicker"
    - "Fast operations (< 150ms) never show loading indicator"
    - "Hook provides consistent isLoading and showLoading pattern"
  artifacts:
    - path: "frontend/hooks/useLoadingState.ts"
      provides: "Loading state with delay mechanism"
      exports: ["useLoadingState"]
    - path: "frontend/hooks/useFetchData.ts"
      provides: "Enhanced data fetching with delay"
      exports: ["useFetchData"]
  key_links:
    - from: "frontend/hooks/useFetchData.ts"
      to: "frontend/hooks/useLoadingState.ts"
      via: "import statement"
      pattern: "import.*useLoadingState"
---

<objective>
Create reusable loading state hooks with delay mechanism

Purpose: Prevent loading state flicker on fast operations and provide consistent loading patterns across application
Output: Custom hooks that introduce 100-200ms delay before showing loading state
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/04-loading-states/04-RESEARCH.md

@frontend/hooks/useFetchData.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useLoadingState hook with delay</name>
  <files>frontend/hooks/useLoadingState.ts</files>
  <action>
    Create frontend/hooks/useLoadingState.ts:

    Implement custom hook that:
    1. Accepts initialDelay parameter (default 150ms)
    2. Manages two states: isLoading (internal) and showLoading (displayed)
    3. Uses setTimeout to delay showing loading state
    4. Clears timeout on unmount or state changes
    5. Returns { isLoading: showLoading, setIsLoading }

    Reference: Pattern 1 from RESEARCH.md (Loading State with Delay)

    Use useState and useEffect hooks
    Implement proper cleanup in useEffect return

    Why 150ms default: Balances preventing flicker with fast feedback for slower operations
  </action>
  <verify>
    Hook file exists and exports useLoadingState:
    grep -q "export.*useLoadingState" frontend/hooks/useLoadingState.ts && echo "Hook exported"
  </verify>
  <done>
    useLoadingState hook created with delay mechanism to prevent flicker
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate delay into useFetchData hook</name>
  <files>frontend/hooks/useFetchData.ts</files>
  <action>
    Update frontend/hooks/useFetchData.ts to use delay mechanism:

    1. Import useLoadingState: `import { useLoadingState } from './useLoadingState'`

    2. Replace existing loading state:
       - Remove: `const [loading, setLoading] = useState<boolean>(true)`
       - Add: `const { isLoading: loading, setIsLoading } = useLoadingState(150)`

    3. Replace all `setLoading(false)` calls with `setIsLoading(false)`
    4. Replace all `setLoading(true)` calls with `setIsLoading(true)`

    Do NOT change any other behavior - cache, error handling, return values stay the same

    This ensures all data fetching using this hook gets automatic delay to prevent flicker
  </action>
  <verify>
    useLoadingState imported and used in hook:
    grep -q "useLoadingState" frontend/hooks/useFetchData.ts && echo "Delay integration found"
  </verify>
  <done>
    useFetchData hook uses delayed loading state to prevent flicker on fast operations
  </done>
</task>

</tasks>

<verification>
1. useLoadingState hook prevents loading indicator from showing for operations < 150ms
2. useFetchData hook uses delayed loading state
3. Zero TypeScript errors after changes
4. Cache behavior in useFetchData unchanged
5. Error handling in useFetchData unchanged
</verification>

<success_criteria>
1. useLoadingState hook created with 150ms default delay
2. useFetchData refactored to use useLoadingState
3. Fast API responses (< 150ms) don't show loading indicator
4. Slow operations (> 150ms) show loading indicator smoothly
5. No breaking changes to useFetchData API
</success_criteria>

<output>
After completion, create `.planning/phases/04-loading-states/04-02-SUMMARY.md`
</output>
