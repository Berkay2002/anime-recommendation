---
phase: 04-loading-states
plan: 05
type: execute
wave: 2
depends_on: [04-01, 04-02]
files_modified:
  - frontend/app/anime/page.tsx
  - frontend/app/anime/[id]/page.tsx
autonomous: false

must_haves:
  truths:
    - "Anime browse page shows loading state during search/filter operations"
    - "Anime detail page shows skeleton during initial data load"
    - "Loading states use delay to prevent flicker on fast operations"
    - "All loading states have proper ARIA attributes"
  artifacts:
    - path: "frontend/app/anime/page.tsx"
      provides: "Browse page with integrated loading indicators"
    - path: "frontend/app/anime/[id]/page.tsx"
      provides: "Detail page with skeleton and error states"
  key_links:
    - from: "frontend/app/anime/page.tsx"
      to: "frontend/hooks/useLoadingState.ts"
      via: "useLoadingState hook import"
      pattern: "import.*useLoadingState"
    - from: "frontend/app/anime/page.tsx"
      to: "frontend/components/loading/LoadingSpinner.tsx"
      via: "LoadingSpinner component import"
      pattern: 'import.*LoadingSpinner'
---

<objective>
Integrate loading states into anime browse and detail pages

Purpose: Provide consistent loading feedback during search, filtering, and page navigation with delay to prevent flicker
Output: Enhanced pages with proper loading states and accessibility
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/04-loading-states/04-RESEARCH.md

@frontend/app/anime/page.tsx
@frontend/app/anime/[id]/page.tsx
@frontend/components/AnimeBrowseGrid.tsx
@frontend/components/AnimeDetailSkeleton.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate loading states into anime browse page</name>
  <files>frontend/app/anime/page.tsx</files>
  <action>
    Update frontend/app/anime/page.tsx to use improved loading states:

    Current state uses: loading, isInitialLoad, setLoading
    Goal: Use useLoadingState hook for delay mechanism

    1. Import useLoadingState: `import { useLoadingState } from '@/hooks/useLoadingState'`
    2. Import LoadingSpinner: `import { LoadingSpinner } from '@/components/loading'`

    3. Replace loading state:
       - Remove: `const [loading, setLoading] = useState<boolean>(true)`
       - Add: `const { isLoading: loading, setIsLoading } = useLoadingState(150)`

    4. Update all setLoading() calls to setIsLoading()

    5. Update render logic:
       - Replace existing loading indicators with LoadingSpinner component
       - Show LoadingSpinner when loading is true AND isInitialLoad is true (initial page load)
       - Show LoadingSpinner inline when loading is true (filter/sort changes)
       - Keep existing AnimeBrowseGrid for loaded state

    6. Add ARIA attributes to loading container:
       - Wrap loading indicator with div having role="status", aria-live="polite", aria-busy={loading}

    Do NOT change existing data fetching logic - only replace loading state management and UI

    Why 150ms delay: Prevents flicker when filters/sort change quickly, but shows loading for slower API calls
  </action>
  <verify>
    useLoadingState imported and used:
    grep -q "useLoadingState" frontend/app/anime/page.tsx && echo "Hook integration found"

    LoadingSpinner component used:
    grep -q "LoadingSpinner" frontend/app/anime/page.tsx && echo "Spinner component found"
  </verify>
  <done>
    Anime browse page uses delayed loading state with LoadingSpinner component
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance anime detail page loading states</name>
  <files>frontend/app/anime/[id]/page.tsx</files>
  <action>
    Update frontend/app/anime/[id]/page.tsx for better loading UX:

    1. Read the current file to understand loading patterns
    2. Import useLoadingState hook if not present
    3. Replace any immediate loading states with useLoadingState for delay

    4. Ensure AnimeDetailSkeleton is used for initial page load:
       - Show skeleton when data is loading on mount
       - Skeleton should have ARIA attributes (inherited from enhanced Skeleton component)

    5. For separate data sections (recommendations, reviews, Jikan tabs):
       - Use inline LoadingSpinner for section-specific loading
       - Each section should have independent loading state
       - Use useLoadingState for each section to prevent flicker

    6. Add ARIA attributes to loading containers:
       - role="status" on loading containers
       - aria-live="polite" for non-critical updates
       - aria-busy={isLoading} for each section

    Look for patterns like:
    - "loading" state variables
    - Conditional rendering based on data being undefined/null
    - Separate fetch operations for different sections

    Goal: Progressive loading where each section reveals independently as data loads
  </action>
  <verify>
    Progressive loading implemented:
    grep -E 'useLoadingState|LoadingSpinner|AnimeDetailSkeleton' frontend/app/anime/[id]/page.tsx && echo "Loading enhancements found"
  </verify>
  <done>
    Anime detail page shows skeleton on initial load, inline spinners for section updates, with proper accessibility
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete loading state integration for browse and detail pages</what-built>
  <how-to-verify>
    Test Anime Browse Page:
    1. Open http://localhost:3000/anime
    2. Verify skeleton or spinner shows on initial load
    3. Change genre filter - verify spinner shows (after 150ms delay)
    4. Change sort option - verify spinner shows
    5. Quick filter changes (< 150ms) should NOT show spinner

    Test Anime Detail Page:
    6. Click any anime card to open detail page
    7. Verify skeleton shows during initial load
    8. Verify content reveals progressively (recommendations, then reviews, etc.)
    9. Verify no layout shift when content loads
    10. Check browser console for errors

    Verify Accessibility:
    11. Enable screen reader or browser accessibility tools
    12. Verify loading states are announced
  </how-to-verify>
  <resume-signal>Type "approved" if loading states work smoothly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Anime browse page shows loading state during filter/sort changes
2. Loading state delays 150ms to prevent flicker on fast operations
3. Anime detail page shows skeleton on initial page load
4. Detail page sections load progressively (not all-or-nothing)
5. All loading states have ARIA attributes
6. Zero TypeScript errors
7. Zero console errors during testing
</verification>

<success_criteria>
1. useLoadingState hook integrated into both pages
2. LoadingSpinner component used for inline loading
3. AnimeDetailSkeleton used for detail page initial load
4. Progressive loading implemented for detail page sections
5. Loading states delayed 150ms to prevent flicker
6. ARIA attributes present on all loading containers
7. Manual verification passes - user approves loading UX
</success_criteria>

<output>
After completion, create `.planning/phases/04-loading-states/04-05-SUMMARY.md`
</output>
