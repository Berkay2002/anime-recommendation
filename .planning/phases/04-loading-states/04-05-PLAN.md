---
phase: 04-loading-states
plan: 05
type: execute
wave: 2
depends_on: [04-01, 04-02, 04-03]
files_modified:
  - frontend/app/anime/page.tsx
  - frontend/app/anime/[id]/page.tsx
  - frontend/components/SearchBar.tsx
autonomous: false

must_haves:
  truths:
    - "Anime browse page shows loading state during search/filter operations"
    - "SearchBar shows loading indicator during search operations"
    - "Anime detail page shows skeleton during initial data load"
    - "Loading states use delay to prevent flicker on fast operations"
    - "All loading states have proper ARIA attributes"
  artifacts:
    - path: "frontend/app/anime/page.tsx"
      provides: "Browse page with integrated loading indicators"
    - path: "frontend/app/anime/[id]/page.tsx"
      provides: "Detail page with skeleton and error states"
    - path: "frontend/components/SearchBar.tsx"
      provides: "SearchBar with delayed loading state"
  key_links:
    - from: "frontend/app/anime/page.tsx"
      to: "frontend/hooks/useLoadingState.ts"
      via: "useLoadingState hook import"
      pattern: "import.*useLoadingState"
    - from: "frontend/app/anime/page.tsx"
      to: "frontend/components/loading/LoadingSpinner.tsx"
      via: "LoadingSpinner component import"
      pattern: 'import.*LoadingSpinner'
    - from: "frontend/components/SearchBar.tsx"
      to: "frontend/hooks/useLoadingState.ts"
      via: "useLoadingState hook import"
      pattern: "import.*useLoadingState"
    - from: "frontend/components/SearchBar.tsx"
      to: "frontend/components/loading/LoadingSpinner.tsx"
      via: "LoadingSpinner component import"
      pattern: 'import.*LoadingSpinner'
---

<objective>
Integrate loading states into anime browse, detail, and search components

Purpose: Provide consistent loading feedback during search, filtering, and page navigation with delay to prevent flicker
Output: Enhanced components with proper loading states and accessibility
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/04-loading-states/04-RESEARCH.md

@frontend/app/anime/page.tsx
@frontend/app/anime/[id]/page.tsx
@frontend/components/SearchBar.tsx
@frontend/components/AnimeBrowseGrid.tsx
@frontend/components/AnimeDetailSkeleton.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate loading states into anime browse page</name>
  <files>frontend/app/anime/page.tsx</files>
  <action>
    Update frontend/app/anime/page.tsx to use improved loading states:

    Current state uses: loading, isInitialLoad, setLoading
    Goal: Use useLoadingState hook for delay mechanism

    1. Import useLoadingState: `import { useLoadingState } from '@/hooks/useLoadingState'`
    2. Import LoadingSpinner: `import { LoadingSpinner } from '@/components/loading'`

    3. Replace loading state:
       - Remove: `const [loading, setLoading] = useState<boolean>(true)`
       - Add: `const { isLoading: loading, setIsLoading } = useLoadingState(150)`

    4. Update all setLoading() calls to setIsLoading()

    5. Update render logic:
       - Replace existing loading indicators with LoadingSpinner component
       - Show LoadingSpinner when loading is true AND isInitialLoad is true (initial page load)
       - Show LoadingSpinner inline when loading is true (filter/sort changes)
       - Keep existing AnimeBrowseGrid for loaded state

    6. Add ARIA attributes to loading container:
       - Wrap loading indicator with div having role="status", aria-live="polite", aria-busy={loading}

    Do NOT change existing data fetching logic - only replace loading state management and UI

    Why 150ms delay: Prevents flicker when filters/sort change quickly, but shows loading for slower API calls
  </action>
  <verify>
    useLoadingState imported and used:
    grep -q "useLoadingState" frontend/app/anime/page.tsx && echo "Hook integration found"

    LoadingSpinner component used:
    grep -q "LoadingSpinner" frontend/app/anime/page.tsx && echo "Spinner component found"
  </verify>
  <done>
    Anime browse page uses delayed loading state with LoadingSpinner component
  </done>
</task>

<task type="auto">
  <name>Task 2: Add loading state to SearchBar component</name>
  <files>frontend/components/SearchBar.tsx</files>
  <action>
    Update frontend/components/SearchBar.tsx to use delayed loading state:

    Current state: Uses isLoading state with immediate display
    Goal: Use useLoadingState hook to prevent flicker on fast searches

    1. Import useLoadingState: `import { useLoadingState } from '@/hooks/useLoadingState'`
    2. Import LoadingSpinner: `import { LoadingSpinner } from '@/components/loading'`

    3. Replace loading state (line 38):
       - Remove: `const [isLoading, setIsLoading] = useState(false)`
       - Add: `const { isLoading, setIsLoading } = useLoadingState(150)`

    4. Replace the inline loading UI (lines 136-139):
       Current: Custom Loader2 icon with "Searching..." text
       Replace with: `<LoadingSpinner size="sm" message="Searching..." />`

    5. Add ARIA attributes to results container (line 132):
       - Add: role="status", aria-live="polite", aria-busy={isLoading}

    6. Update all setIsLoading() calls to use the new hook

    Do NOT change existing debounce logic or search behavior - only replace loading state management

    Why 150ms delay: Search already has 300ms debounce, so fast searches won't flicker, but slower searches will show loading state smoothly
  </action>
  <verify>
    useLoadingState imported and used:
    grep -q "useLoadingState" frontend/components/SearchBar.tsx && echo "Hook integration found"

    LoadingSpinner component used:
    grep -q "LoadingSpinner" frontend/components/SearchBar.tsx && echo "Spinner component found"
  </verify>
  <done>
    SearchBar uses delayed loading state to prevent flicker on fast searches
  </done>
</task>

<task type="auto">
  <name>Task 3: Set up anime detail page initial load skeleton</name>
  <files>frontend/app/anime/[id]/page.tsx</files>
  <action>
    Update frontend/app/anime/[id]/page.tsx for initial page load skeleton:

    1. Read the current file to understand loading patterns
    2. Import useLoadingState hook: `import { useLoadingState } from '@/hooks/useLoadingState'`
    3. Import AnimeDetailSkeleton: `import { AnimeDetailSkeleton } from '@/components/AnimeDetailSkeleton'`

    4. Replace initial loading state with useLoadingState:
       - Find the initial loading state variable (likely `loading` or similar)
       - Replace with: `const { isLoading, setIsLoading } = useLoadingState(150)`

    5. Ensure AnimeDetailSkeleton is shown during initial page load:
       - When isLoading is true on mount, render <AnimeDetailSkeleton />
       - Skeleton should have proper ARIA attributes (inherited from enhanced Skeleton component)
       - Ensure skeleton matches the layout of actual content to prevent layout shift

    6. Add ARIA attributes to main loading container:
       - role="status" on the container showing skeleton
       - aria-live="polite" for non-critical updates
       - aria-busy={isLoading}

    Do NOT change data fetching logic - only replace loading state management and initial load UI
  </action>
  <verify>
    AnimeDetailSkeleton used for initial load:
    grep -E 'AnimeDetailSkeleton|useLoadingState' frontend/app/anime/[id]/page.tsx && echo "Skeleton setup found"
  </verify>
  <done>
    Anime detail page shows skeleton on initial load with proper accessibility
  </done>
</task>

<task type="auto">
  <name>Task 4: Add progressive loading to anime detail page sections</name>
  <files>frontend/app/anime/[id]/page.tsx</files>
  <action>
    Update frontend/app/anime/[id]/page.tsx for progressive loading of sections:

    1. Import LoadingSpinner: `import { LoadingSpinner } from '@/components/loading'`

    2. Identify separate data sections that load independently:
       - Recommendations section
       - Reviews section
       - Jikan API tabs (characters, staff, episodes, etc.)

    3. For each section with separate data fetching:
       - Add independent loading state using useLoadingState(150)
       - Show inline LoadingSpinner when section is loading
       - Size="sm" for sections, size="md" for larger areas
       - Include message prop: "Loading recommendations...", "Loading reviews..."

    4. Add ARIA attributes to each section's loading container:
       - role="status" on section container
       - aria-live="polite" for non-critical updates
       - aria-busy={isSectionLoading}

    Look for patterns like:
    - Separate useEffect hooks for different data sources
    - Conditional rendering based on data being undefined/null
    - Separate fetch operations for recommendations, reviews, Jikan data

    Goal: Each section reveals independently as data loads (progressive loading), not all-or-nothing
  </action>
  <verify>
    Progressive loading implemented for sections:
    grep -E 'useLoadingState|LoadingSpinner' frontend/app/anime/[id]/page.tsx && echo "Progressive loading found"
  </verify>
  <done>
    Anime detail page sections load progressively with inline loading spinners
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete loading state integration for browse, detail, and search components</what-built>
  <how-to-verify>
    Test Anime Browse Page:
    1. Open http://localhost:3000/anime
    2. Verify skeleton or spinner shows on initial load
    3. Change genre filter - verify spinner shows (after 150ms delay)
    4. Change sort option - verify spinner shows
    5. Quick filter changes (< 150ms) should NOT show spinner

    Test SearchBar:
    6. Click search icon or press Ctrl+K
    7. Type anime title slowly - verify no flickering during search
    8. Type anime title - verify "Searching..." message shows after delay
    9. Verify search results appear smoothly

    Test Anime Detail Page:
    10. Click any anime card to open detail page
    11. Verify skeleton shows during initial load
    12. Verify content reveals progressively (recommendations, then reviews, etc.)
    13. Verify no layout shift when content loads
    14. Check browser console for errors

    Verify Accessibility:
    15. Enable screen reader or browser accessibility tools
    16. Verify loading states are announced properly
  </how-to-verify>
  <resume-signal>Type "approved" if loading states work smoothly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Anime browse page shows loading state during filter/sort changes
2. SearchBar shows loading state during search operations
3. Loading state delays 150ms to prevent flicker on fast operations
4. Anime detail page shows skeleton on initial page load
5. Detail page sections load progressively (not all-or-nothing)
6. All loading states have ARIA attributes
7. Zero TypeScript errors
8. Zero console errors during testing
</verification>

<success_criteria>
1. useLoadingState hook integrated into all three components
2. LoadingSpinner component used for inline loading
3. AnimeDetailSkeleton used for detail page initial load
4. Progressive loading implemented for detail page sections
5. Loading states delayed 150ms to prevent flicker
6. ARIA attributes present on all loading containers
7. Manual verification passes - user approves loading UX
</success_criteria>

<output>
After completion, create `.planning/phases/04-loading-states/04-05-SUMMARY.md`
</output>
